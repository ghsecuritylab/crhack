*******************************************************************************

        问题
        ----
        如果某个源代码或静态库里包含 start 入口点
        那么用 BCC32 + ILINK32 时它就会覆盖你程序里的入口点
        导致程序变得面目全非，jcalg1_bc.lib 就是一个例子
        只要把它链接进来，无论是 EXE 还是 DLL
        入口点全都变成它里面的 start (一个空函数)

        解决
        ----
        去掉第三方库源代码里的入口点，重新编译之

        总结
        ----
        使用第三方库尤其是静态库的时候要注意它是否有自己的入口点

*******************************************************************************

        问题
        ----
        使用 BCC32 + ILINK32 生成的程序出现莫名其妙的崩溃
        问题出在使用的静态库
        同样是 jcalg1_bc.lib，它使用 TASM32 编译
        代码里如有 align N 则 TASM32 会用非 nop 指令来填充
        （如: xchg ebx, ebx）
        但是到了 BCC32 + ILINK32 里会将其转化为 0x00
        这将导致代码段变得面目全非，运行时造成崩溃

        解决
        ----
        去掉源代码里的 align 伪指令，重新编译之

        总结
        ----
        使用 TASM32 写汇编代码时不要在代码里插入 align 伪指令
        但加在过程的头部没问题

*******************************************************************************

        问题
        ----
        GCC 宽字符串的问题

        解决
        ----
        使用命令行参数
        -fshort-wchar    -finput-charset=charset
        -fwide-exec-charset=charset 指定源文件编码格式

        总结
        ----
        GCC 在 Windows 下 wchar_t 默认为2个字节
        在 Linux 下默认为4个字节，可以用 -fshort-wchar 指定大小
        但无法影响已经编译好的库，所以 Linux 下
        如果指定了它就最好不要再使用 wcs 系的字符串库函数
        GCC 总是假设源代码编码类型是没有 BOM 的 UTF-8
        所以默认情况下如有 L"中文" 则会出错
        需要用 -finput-charset=charset 指定输入编码
        另外 -fwide-exec-charset=charset 是用来指定字符串编译后保存的编码
        在 Windows 下默认为 UTF-16，在 Linux 下默认为 UTF-32

        注意
        ----
        以上指定编码的功能需要 iconv 命令行的支持，否则无法使用
        所以尽量不要在源代码和字符串里使用包含非 ASCII 的宽字符

*******************************************************************************

        问题
        ----
        关于 sARRAY 或 sCURTAIN 内保存 sARRAY 实体指针崩溃的问题

        解决
        ----
        待所有实体压完之后再注册指针 (同样适用于 vector<T>)

        总结
        ----
        因为压入实体的时候，内存可能会重新分配，使所有先前注册的指针无效

*******************************************************************************

        问题
        ----
        BDS2006 关于字符比较的代码总是出 W8012 警告

        解决
        ----
        在字符常量前面加上强制类型转换或手工关闭警告

        总结
        ----
        因为 BCB 的 C 代码编译下 sizeof('a') = 4，且是无符号数
        而 BDS2006 默认打开 W8012 警告，所以会出现上述警告
        在 BCB6 和 BDS2007 里默认是关闭这个警告的

*******************************************************************************

        问题
        ----
        BCB 下 PCRE 库总是运作不正常

        解决
        ----
        重命名 PCRE 库函数，重新编译之

        总结
        ----
        BCB 自己也带了一个 PCRE 库
        函数的参数个数与开源版本的不同
        在生成代码时 BCB 总是链接到自己的 PCRE 库上
        所以重命名用到的函数名可以解决问题

*******************************************************************************

        问题
        ----
        对于 PCRE 返回数组的说明

        总结
        ----
        返回的数组两个整数一对
        但是传入参数 ovecsize 必须是3的倍数
        第一个数字表示匹配的开始，第二个数字表示匹配的结束+1
        数组中第一对数字表示总的匹配信息
        数组中后续的数字对表示正则表达式匹配的子信息 (位于总匹配内部)

*******************************************************************************

        问题
        ----
        GDI 绘图总是少两条边

        解决
        ----
        自己将右下角的坐标 X 和 Y 加一

        总结
        ----
        凡是涉及到 GDI RECT 结构的区域，右下的边总是不包括在区域内的

*******************************************************************************

        问题
        ----
        KeilC51 编译有很多没调用的函数时会报内存溢出

        解决
        ----
        (1) 用宏开关剔除这些没有用到的函数，这就需要定义很多宏
            并以包含的方式编译代码，对驱动模板比较有效
        (2) 在主函数里一个永远无法达到的地方调用这些函数，这对已有的
            函数库比较有效

        总结
        ----
        KeilC51 以覆盖的方式分配局部变量，它遍历所有的函数，统计调用
        关系，然后计算内存用量，如果有函数没有被调用，此函数使用到的内存
        将不归入可覆盖内存之内，由此造成内存用量溢出

*******************************************************************************
